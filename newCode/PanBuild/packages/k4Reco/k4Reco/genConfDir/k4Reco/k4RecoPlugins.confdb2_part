{
    'DDPlanarDigi': {
        '__component_type__': 'Algorithm',
        '__declaration_location__': 'DDPlanarDigi.h:137',
        '__interfaces__': ('IDataHandleHolder', 'IStateful', ),
        'properties': {
            'ExtraInputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'ExtraOutputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'OutputLevel': ('int', 0, '''output level [Gaudi::Algorithm]'''),
            'Enable': ('bool', True, '''should the algorithm be executed or not [Gaudi::Algorithm]'''),
            'ErrorMax': ('unsigned int', 1, '''[[deprecated]] max number of errors [Gaudi::Algorithm]'''),
            'AuditAlgorithms': ('bool', False, '''[[deprecated]] unused [Gaudi::Algorithm]'''),
            'AuditInitialize': ('bool', False, '''trigger auditor on initialize() [Gaudi::Algorithm]'''),
            'AuditReinitialize': ('bool', False, '''trigger auditor on reinitialize() [Gaudi::Algorithm]'''),
            'AuditRestart': ('bool', False, '''trigger auditor on restart() [Gaudi::Algorithm]'''),
            'AuditExecute': ('bool', False, '''trigger auditor on execute() [Gaudi::Algorithm]'''),
            'AuditFinalize': ('bool', False, '''trigger auditor on finalize() [Gaudi::Algorithm]'''),
            'AuditStart': ('bool', False, '''trigger auditor on start() [Gaudi::Algorithm]'''),
            'AuditStop': ('bool', False, '''trigger auditor on stop() [Gaudi::Algorithm]'''),
            'Timeline': ('bool', True, '''send events to TimelineSvc [Gaudi::Algorithm]'''),
            'MonitorService': ('std::string', 'MonitorSvc', '''name to use for Monitor Service [Gaudi::Algorithm]'''),
            'RegisterForContextService': ('bool', False, '''flag to enforce the registration for Algorithm Context Service [Gaudi::Algorithm]'''),
            'Cardinality': ('int', 0, '''how many clones to create - 0 means algo is reentrant [Gaudi::Algorithm]'''),
            'NeededResources': ('std::vector<std::string,std::allocator<std::string> >', [  ], '''named resources needed during event looping [Gaudi::Algorithm]'''),
            'Asynchronous': ('bool', False, '''whether algorithm is asynchronous and uses Boost Fiber to suspend while offloaded code is running. [Gaudi::Algorithm]'''),
            'FilterCircularDependencies': ('bool', True, '''filter out circular data dependencies [Gaudi::Algorithm]'''),
            'SimTrackerHitCollectionName': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'SimTrackerHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&,edm4hep::EventHeaderCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'HeaderName': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'EventHeader' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&,edm4hep::EventHeaderCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'TrackerHitCollectionName': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'VTXTrackerHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&,edm4hep::EventHeaderCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'SimTrkHitRelCollection': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'VTXTrackerHitRelations' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&,edm4hep::EventHeaderCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'SubDetectorName': ('std::string', 'VXD', '''Name of the subdetector [DDPlanarDigi]'''),
            'IsStrip': ('bool', False, '''Whether the hits are 1D strip hits [DDPlanarDigi]'''),
            'ResolutionU': ('std::vector<float,std::allocator<float> >', [ 0.00400000 ], '''Resolution in the direction of u; either one per layer or one for all layers [DDPlanarDigi]'''),
            'ResolutionV': ('std::vector<float,std::allocator<float> >', [ 0.00400000 ], '''Resolution in the direction of v; either one per layer or one for all layers [DDPlanarDigi]'''),
            'ResolutionT': ('std::vector<float,std::allocator<float> >', [ -1.00000 ], '''Resolution in the direction of t; either one per layer or one for all layers. If the single entry is negative, disable time smearing.  [DDPlanarDigi]'''),
            'ForceHitsOntoSurface': ('bool', False, '''Project hits onto the surfoce in case they are not yet on the surface [DDPlanarDigi]'''),
            'MinEnergy': ('double', 0.0000000, '''Minimum energy (GeV) of SimTrackerHit to be digitized [DDPlanarDigi]'''),
            'UseTimeWindow': ('bool', False, '''Only accept hits with time (after smearing) within the specified time window (default: false) [DDPlanarDigi]'''),
            'CorrectTimesForPropagation': ('bool', False, '''Correct hit time for the propagation: radial distance/c (default: false) [DDPlanarDigi]'''),
            'TimeWindowMin': ('std::vector<float,std::allocator<float> >', [ -1.00000e+09 ], '''Minimum time (ns) of SimTrackerHit to be digitized [DDPlanarDigi]'''),
            'TimeWindowMax': ('std::vector<float,std::allocator<float> >', [ 1.00000e+09 ], '''Maximum time (ns) of SimTrackerHit to be digitized [DDPlanarDigi]'''),
            'EncodingStringParameterName': ('std::string', 'GlobalTrackerReadoutID', '''The name of the DD4hep constant that contains the Encoding string for tracking detectors [DDPlanarDigi]'''),
            'GeoSvcName': ('std::string', 'GeoSvc', '''The name of the GeoSvc instance [DDPlanarDigi]'''),
            'MaxTries': ('int', 10, '''Maximum number of tries to find a valid surface for a hit [DDPlanarDigi]'''),
        },
    },
    'OverlayTiming': {
        '__component_type__': 'Algorithm',
        '__declaration_location__': 'OverlayTiming.cpp:461',
        '__interfaces__': ('IDataHandleHolder', 'IStateful', ),
        'properties': {
            'ExtraInputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'ExtraOutputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'OutputLevel': ('int', 0, '''output level [Gaudi::Algorithm]'''),
            'Enable': ('bool', True, '''should the algorithm be executed or not [Gaudi::Algorithm]'''),
            'ErrorMax': ('unsigned int', 1, '''[[deprecated]] max number of errors [Gaudi::Algorithm]'''),
            'AuditAlgorithms': ('bool', False, '''[[deprecated]] unused [Gaudi::Algorithm]'''),
            'AuditInitialize': ('bool', False, '''trigger auditor on initialize() [Gaudi::Algorithm]'''),
            'AuditReinitialize': ('bool', False, '''trigger auditor on reinitialize() [Gaudi::Algorithm]'''),
            'AuditRestart': ('bool', False, '''trigger auditor on restart() [Gaudi::Algorithm]'''),
            'AuditExecute': ('bool', False, '''trigger auditor on execute() [Gaudi::Algorithm]'''),
            'AuditFinalize': ('bool', False, '''trigger auditor on finalize() [Gaudi::Algorithm]'''),
            'AuditStart': ('bool', False, '''trigger auditor on start() [Gaudi::Algorithm]'''),
            'AuditStop': ('bool', False, '''trigger auditor on stop() [Gaudi::Algorithm]'''),
            'Timeline': ('bool', True, '''send events to TimelineSvc [Gaudi::Algorithm]'''),
            'MonitorService': ('std::string', 'MonitorSvc', '''name to use for Monitor Service [Gaudi::Algorithm]'''),
            'RegisterForContextService': ('bool', False, '''flag to enforce the registration for Algorithm Context Service [Gaudi::Algorithm]'''),
            'Cardinality': ('int', 0, '''how many clones to create - 0 means algo is reentrant [Gaudi::Algorithm]'''),
            'NeededResources': ('std::vector<std::string,std::allocator<std::string> >', [  ], '''named resources needed during event looping [Gaudi::Algorithm]'''),
            'Asynchronous': ('bool', False, '''whether algorithm is asynchronous and uses Boost Fiber to suspend while offloaded code is running. [Gaudi::Algorithm]'''),
            'FilterCircularDependencies': ('bool', True, '''filter out circular data dependencies [Gaudi::Algorithm]'''),
            'EventHeader': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'EventHeader' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'MCParticles': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'DefaultMCParticles' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'SimTrackerHits': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'DefaultSimTrackerHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'SimCalorimeterHits': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'DefaultSimCalorimeterHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'OutputMCParticles': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'NewMCParticles' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'OutputSimTrackerHits': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'NewSimTrackerHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'OutputSimCalorimeterHits': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'NewSimCalorimeterHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'OutputCaloHitContributions': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'OverlayCaloHitContributions' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::MCParticleCollection,std::vector<edm4hep::SimTrackerHitCollection,std::allocator<edm4hep::SimTrackerHitCollection> >,std::vector<edm4hep::SimCalorimeterHitCollection,std::allocator<edm4hep::SimCalorimeterHitCollection> >,std::vector<edm4hep::CaloHitContributionCollection,std::allocator<edm4hep::CaloHitContributionCollection> > > (edm4hep::EventHeaderCollection const&,edm4hep::MCParticleCollection const&,std::vector<edm4hep::SimTrackerHitCollection const*,std::allocator<edm4hep::SimTrackerHitCollection const*> > const&,std::vector<edm4hep::SimCalorimeterHitCollection const*,std::allocator<edm4hep::SimCalorimeterHitCollection const*> > const&),Gaudi::Functional::Traits::use_<> >]'''),
            'RandomBx': ('bool', False, '''Place the physics event at an random position in the train: overrides PhysicsBX [OverlayTiming]'''),
            'PhysicsBX': ('int', 1, '''Number of the Bunch crossing of the physics event [OverlayTiming]'''),
            'NBunchtrain': ('int', 1, '''Number of bunches in a bunch train [OverlayTiming]'''),
            'StartBackgroundEventIndex': ('int', -1, '''Which background event to startWith [OverlayTiming]'''),
            'BackgroundFileNames': ('std::vector<std::vector<std::string,std::allocator<std::string> >,std::allocator<std::vector<std::string,std::allocator<std::string> > > >', [  ], '''Name of the edm4hep input file(s) with background. [OverlayTiming]'''),
            'NumberBackground': ('std::vector<double,std::allocator<double> >', [  ], '''Number of Background events to overlay - either fixed or Poisson mean [OverlayTiming]'''),
            'Poisson_random_NOverlay': ('std::vector<bool,std::allocator<bool> >', [  ], '''Draw random number of Events to overlay from Poisson distribution with mean value NumberBackground [OverlayTiming]'''),
            'BackgroundMCParticleCollectionName': ('std::string', 'MCParticle', '''The name of the MCParticle collection in the background files [OverlayTiming]'''),
            'Delta_t': ('float', 0.500000, '''Time difference between BXs in the BXtrain [OverlayTiming]'''),
            'TimeWindows': ('std::map<std::string,std::vector<float,std::allocator<float> >,std::less<std::string>,std::allocator<std::pair<std::string const,std::vector<float,std::allocator<float> > > > >', {  }, '''Time windows for the different collections [OverlayTiming]'''),
            'AllowReusingBackgroundFiles': ('bool', False, '''If true the same background file can be used for the same event [OverlayTiming]'''),
            'CopyCellIDMetadata': ('bool', False, '''If metadata is found in the signal file, copy it to the output file, replacing the old names with the new names [OverlayTiming]'''),
            'MergeMCParticles': ('bool', True, '''Merge the MC Particle collections [OverlayTiming]'''),
        },
    },
}
