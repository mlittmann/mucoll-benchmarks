{
    'DDPlanarDigiAlgorithm': {
        '__component_type__': 'Algorithm',
        '__declaration_location__': 'DDPlanarDigiAlgorithm.cc:29',
        '__interfaces__': ('IDataHandleHolder', 'IStateful', ),
        'properties': {
            'ExtraInputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'ExtraOutputs': ('std::unordered_set<DataObjID,DataObjID_Hasher,std::equal_to<DataObjID>,std::allocator<DataObjID> >', set(), ''' [DataHandleHolderBase<PropertyHolder<CommonMessaging<implements<IAlgorithm,IDataHandleHolder,IProperty,IStateful> > > >]'''),
            'OutputLevel': ('int', 0, '''output level [Gaudi::Algorithm]'''),
            'Enable': ('bool', True, '''should the algorithm be executed or not [Gaudi::Algorithm]'''),
            'ErrorMax': ('unsigned int', 1, '''[[deprecated]] max number of errors [Gaudi::Algorithm]'''),
            'AuditAlgorithms': ('bool', False, '''[[deprecated]] unused [Gaudi::Algorithm]'''),
            'AuditInitialize': ('bool', False, '''trigger auditor on initialize() [Gaudi::Algorithm]'''),
            'AuditReinitialize': ('bool', False, '''trigger auditor on reinitialize() [Gaudi::Algorithm]'''),
            'AuditRestart': ('bool', False, '''trigger auditor on restart() [Gaudi::Algorithm]'''),
            'AuditExecute': ('bool', False, '''trigger auditor on execute() [Gaudi::Algorithm]'''),
            'AuditFinalize': ('bool', False, '''trigger auditor on finalize() [Gaudi::Algorithm]'''),
            'AuditStart': ('bool', False, '''trigger auditor on start() [Gaudi::Algorithm]'''),
            'AuditStop': ('bool', False, '''trigger auditor on stop() [Gaudi::Algorithm]'''),
            'Timeline': ('bool', True, '''send events to TimelineSvc [Gaudi::Algorithm]'''),
            'MonitorService': ('std::string', 'MonitorSvc', '''name to use for Monitor Service [Gaudi::Algorithm]'''),
            'RegisterForContextService': ('bool', False, '''flag to enforce the registration for Algorithm Context Service [Gaudi::Algorithm]'''),
            'Cardinality': ('int', 0, '''how many clones to create - 0 means algo is reentrant [Gaudi::Algorithm]'''),
            'NeededResources': ('std::vector<std::string,std::allocator<std::string> >', [  ], '''named resources needed during event looping [Gaudi::Algorithm]'''),
            'Asynchronous': ('bool', False, '''whether algorithm is asynchronous and uses Boost Fiber to suspend while offloaded code is running. [Gaudi::Algorithm]'''),
            'FilterCircularDependencies': ('bool', True, '''filter out circular data dependencies [Gaudi::Algorithm]'''),
            'SimTrackHitCollectionName': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'VXDCollection' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'TrackerHitCollectionName': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'VTXTrackerHits' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'SimTrkHitRelCollection': ('std::vector<DataObjID,std::allocator<DataObjID> >', [ 'VTXTrackerHitRelations' ], ''' [k4FWCore::details::MultiTransformer<std::tuple<edm4hep::TrackerHitPlaneCollection,edm4hep::TrackerHitSimTrackerHitLinkCollection> (edm4hep::SimTrackerHitCollection const&),Gaudi::Functional::Traits::use_<> >]'''),
            'ResolutionU': ('std::vector<float,std::allocator<float> >', [ 0.00400000 ], '''Resolution in direction of u - either one per layer or one for all layers. [DDPlanarDigiAlgorithm]'''),
            'ResolutionV': ('std::vector<float,std::allocator<float> >', [ 0.00400000 ], '''Resolution in direction of u - either one per layer or one for all layers. [DDPlanarDigiAlgorithm]'''),
            'ResolutionT': ('std::vector<float,std::allocator<float> >', [ -1.00000 ], '''Resolution of time - either one per layer or one for all layers. If the single entry is negative, disable time smearing. [DDPlanarDigiAlgorithm]'''),
            'IsStrip': ('bool', False, '''Whether hits are 1D strip hits. [DDPlanarDigiAlgorithm]'''),
            'SubDetectorName': ('std::string', 'VXD', '''Name of sub detector. [DDPlanarDigiAlgorithm]'''),
            'ForceHitsOntoSurface': ('bool', False, '''Project hits onto the surface in case they are not yet on the surface (default: false). [DDPlanarDigiAlgorithm]'''),
            'MinimumEnergyPerHit': ('double', 0.0000000, '''Minimum Energy (in GeV!) to accept hits, other hits are ignored. [DDPlanarDigiAlgorithm]'''),
            'CorrectTimesForPropagation': ('bool', False, '''Correct hit time for the propagation: radial distance/c (default: false). [DDPlanarDigiAlgorithm]'''),
            'UseTimeWindow': ('bool', False, '''Only accept hits with time (after smearing) within the specified time window (default: false). [DDPlanarDigiAlgorithm]'''),
            'TimeWindowMin': ('std::vector<float,std::allocator<float> >', [ -1.00000e+09 ], '''Minimum time a hit must have after smearing to be accepted [ns] - either one per layer or one for all layers. [DDPlanarDigiAlgorithm]'''),
            'TimeWindowMax': ('std::vector<float,std::allocator<float> >', [ 1.00000e+09 ], '''Maximum time a hit must have after smearing to be accepted [ns] - either one per layer or one for all layers. [DDPlanarDigiAlgorithm]'''),
            'EncodingStringParameterName': ('std::string', 'GlobalTrackerReadoutID', '''The name of the DD4hep constant that contains the Encoding string for the detector [DDPlanarDigiAlgorithm]'''),
        },
    },
}
